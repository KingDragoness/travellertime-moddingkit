using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using DestinyEngine;
using UnityStandardAssets.Utility;
using Rewired;

namespace EVP.DestinyEngine
{
    public class MCV_Extension_Propeller : MonoBehaviour, ICommand
    {
        public List<ActionCommand_Parent> PropellerCommands = new List<ActionCommand_Parent>();

        [SerializeField] private float m_Lift = 0.002f;               // The amount of lift generated by the aeroplane moving forwards.
        [SerializeField] private float m_ZeroLiftSpeed = 300;         // The speed at which lift is no longer applied.

        public float EnginePower { get; private set; }                  // How much power the engine is being given.
        public float ForwardSpeed { get; private set; }

        private float m_AeroFactor;


        public float speed = 500;
        public AutoMoveAndRotate autoMoveAndRotate;

        private MCV_BodyParts bodyPart;
        private Rigidbody m_Rigidbody;
        private Player player;
        private bool isOn = false;

        public void CommandExecute(ActionCommand command)
        {
            if (command.commandID == "Toggle.Propeller")
            {
                isOn = !isOn;
            }
        }

        public void CommandExecute(string functionName)
        {
            throw new System.NotImplementedException();
        }

        public List<ActionCommand_Parent> CommandListRetrieveAll()
        {
            return PropellerCommands;
        }

        private void Start()
        {
            bodyPart = GetComponent<MCV_BodyParts>();
            player = ReInput.players.GetPlayer(0);
            m_Rigidbody = bodyPart.ModularCustomVehicle.vehicleRigidbody;
        }

        private void Update()
        {
            if (bodyPart.ModularCustomVehicle == null)
            {
                return;
            }

            if (isOn)
            {
                autoMoveAndRotate.enabled = true;

                CalculateForwardSpeed();
                ControlThrottle();
                CalculateLinearForces();
                //LegacyTest();
            }
            else
            {
                autoMoveAndRotate.enabled = false;
            }
        }

        private void LegacyTest()
        {

            if (bodyPart.ModularCustomVehicle.vehicle.throttleInput > 0.9f)
                bodyPart.ModularCustomVehicle.vehicleRigidbody.AddForce(bodyPart.ModularCustomVehicle.transform.forward
                    * bodyPart.ModularCustomVehicle.vehicle.maxDriveForce
                    * speed * Time.deltaTime);
        }

        private void ControlThrottle()
        {
            float Throttle = bodyPart.ModularCustomVehicle.vehicle.throttleInput;
            float m_MaxEnginePower = bodyPart.ModularCustomVehicle.vehicle.maxDriveForce;

            // current engine power is just:
            EnginePower = Throttle * m_MaxEnginePower * speed;
        }


        private void CalculateForwardSpeed()
        {
            // Forward speed is the speed in the planes's forward direction (not the same as its velocity, eg if falling in a stall)
            var localVelocity = bodyPart.ModularCustomVehicle.transform.InverseTransformDirection(m_Rigidbody.velocity);
            ForwardSpeed = Mathf.Max(0, localVelocity.z);
        }

        private void CalculateLinearForces()
        {

            // Now calculate forces acting on the aeroplane:
            // we accumulate forces into this variable:
            var forces = Vector3.zero;
            // Add the engine power in the forward direction
            forces += EnginePower * bodyPart.ModularCustomVehicle.transform.forward;
            // The direction that the lift force is applied is at right angles to the plane's velocity (usually, this is 'up'!)
            var liftDirection = Vector3.Cross(m_Rigidbody.velocity, bodyPart.ModularCustomVehicle.transform.right).normalized;
            // The amount of lift drops off as the plane increases speed - in reality this occurs as the pilot retracts the flaps
            // shortly after takeoff, giving the plane less drag, but less lift. Because we don't simulate flaps, this is
            // a simple way of doing it automatically:
            var zeroLiftFactor = Mathf.InverseLerp(m_ZeroLiftSpeed, 0, ForwardSpeed);
            // Calculate and add the lift power
            var liftPower = ForwardSpeed * ForwardSpeed * m_Lift * zeroLiftFactor * m_AeroFactor;
            forces += liftPower * liftDirection;
            // Apply the calculated forces to the the Rigidbody
            m_Rigidbody.AddForce(forces);
        }


    }
}
